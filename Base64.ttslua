-- Base64 implementation originally based on https://github.com/iskolbin/lbase64 (public domain),
-- but modified for simplicity, TTS and to take/return tables rather than strings.

ge_tts_package('ge_tts/Base64', function()
    local Base64 = {}

    local extract = bit32.extract

    function Base64.makeencoder( s62, s63, spad )
        local encoder = {}
        for b64code, char in pairs{[0]='A','B','C','D','E','F','G','H','I','J',
            'K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y',
            'Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n',
            'o','p','q','r','s','t','u','v','w','x','y','z','0','1','2',
            '3','4','5','6','7','8','9',s62 or '+',s63 or'/',spad or'='} do
            encoder[b64code] = char:byte()
        end
        return encoder
    end

    function Base64.makedecoder( s62, s63, spad )
        local decoder = {}
        for b64code, charcode in pairs( Base64.makeencoder( s62, s63, spad )) do
            decoder[charcode] = b64code
        end
        return decoder
    end

    local DEFAULT_ENCODER = Base64.makeencoder()
    local DEFAULT_DECODER = Base64.makedecoder()

    function Base64.encode(buffer, encoder)
        encoder = encoder or DEFAULT_ENCODER

        local components = {}
        local index = 1
        local length = #buffer
        local lastn = length % 3

        for offset = 1, length - lastn, 3 do
            local a, b, c = table.unpack(buffer, offset, offset + 2)
            local v = a*0x10000 + b*0x100 + c

            components[index] = string.char(encoder[extract(v,18,6)], encoder[extract(v,12,6)], encoder[extract(v,6,6)], encoder[extract(v,0,6)])
            index = index + 1
        end

        if lastn == 2 then
            local a, b = table.unpack(buffer, length - 1, length)
            local v = a*0x10000 + b*0x100

            components[index] = string.char(encoder[extract(v,18,6)], encoder[extract(v,12,6)], encoder[extract(v,6,6)], encoder[64])
        elseif lastn == 1 then
            local v = buffer[length]*0x10000

            components[index] = string.char(encoder[extract(v,18,6)], encoder[extract(v,12,6)], encoder[64], encoder[64])
        end

        return table.concat(components)
    end

    function Base64.decode(b64, decoder)
        decoder = decoder or DEFAULT_DECODER

        local buffer = {}
        local offset = 1

        local length = #b64
        local padding = b64:sub(-2) == '==' and 2 or b64:sub(-1) == '=' and 1 or 0

        for i = 1, padding > 0 and length - 4 or length, 4 do
            local a, b, c, d = b64:byte( i, i+3 )

            local v = decoder[a]*0x40000 + decoder[b]*0x1000 + decoder[c]*0x40 + decoder[d]

            buffer[offset] = extract(v,16,8)
            buffer[offset + 1] = extract(v,8,8)
            buffer[offset + 2] = extract(v,0,8)

            offset = offset + 3
        end

        if padding == 1 then
            local a, b, c = b64:byte( length -3, length -1 )
            local v = decoder[a]*0x40000 + decoder[b]*0x1000 + decoder[c]*0x40

            buffer[offset] = extract(v,16,8)
            buffer[offset + 1] = extract(v,8,8)
        elseif padding == 2 then
            local a, b = b64:byte( length -3, length -2 )
            local v = decoder[a]*0x40000 + decoder[b]*0x1000

            buffer[offset] = extract(v,16,8)
        end

        return buffer
    end

    return Base64
end)
