-- Base64 implementation originally based on https://github.com/iskolbin/lbase64 (public domain),
-- but modified for simplicity, TTS and to take/return tables rather than strings.

ge_tts_package('ge_tts/Base64', function()
    ---@type ge_tts__TableUtils
    local TableUtils = ge_tts_require('ge_tts/TableUtils')

    ---@type ge_tts__Base64
    local Base64 = {}

    local extract = bit32.extract

    ---@param char62 string
    ---@param char63 string
    ---@param charPad string
    ---@return table<string, string>
    function Base64.encodingMap(char62, char63, charPad)
        local encodingTable = {}

        for b64code, char in pairs({
            [0] = 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',
            'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y',
            'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
            'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2',
            '3', '4', '5', '6', '7', '8', '9', char62 or '+', char63 or '/', charPad or '='
        }) do
            encodingTable[b64code] = char:byte()
        end

        return encodingTable
    end

    ---@param char62 string
    ---@param char63 string
    ---@param charPad string
    ---@return table<string, string>
    function Base64.decodingMap(char62, char63, charPad)
        return TableUtils.invert(Base64.encodingMap(char62, char63, charPad))
    end

    local DEFAULT_ENCODING_MAP = Base64.encodingMap()
    local DEFAULT_DECODING_MAP = Base64.decodingMap()

    ---@param buffer number[]
    ---@param map table<string, string>
    ---@return string
    function Base64.encode(buffer, map)
        map = map or DEFAULT_ENCODING_MAP

        local components = {}
        local index = 1
        local length = #buffer
        local lastComponentSize = length % 3

        for offset = 1, length - lastComponentSize, 3 do
            local a, b, c = table.unpack(buffer, offset, offset + 2)
            local v = a * 0x10000 + b * 0x100 + c

            components[index] = string.char(map[extract(v, 18, 6)], map[extract(v, 12, 6)], map[extract(v, 6, 6)], map[extract(v, 0, 6)])
            index = index + 1
        end

        if lastComponentSize == 2 then
            local a, b = table.unpack(buffer, length - 1, length)
            local v = a * 0x10000 + b * 0x100

            components[index] = string.char(map[extract(v, 18, 6)], map[extract(v, 12, 6)], map[extract(v, 6, 6)], map[64])
        elseif lastComponentSize == 1 then
            local v = buffer[length] * 0x10000

            components[index] = string.char(map[extract(v, 18, 6)], map[extract(v, 12, 6)], map[64], map[64])
        end

        return table.concat(components)
    end

    ---@param b64 string
    ---@param map table<string, string>
    ---@return number[]
    function Base64.decode(b64, map)
        map = map or DEFAULT_DECODING_MAP

        local buffer = {}
        local offset = 1

        local length = #b64
        local padding = b64:sub(-2) == '==' and 2 or b64:sub(-1) == '=' and 1 or 0

        for i = 1, padding > 0 and length - 4 or length, 4 do
            local a, b, c, d = b64:byte(i, i + 3)

            local v = map[a] * 0x40000 + map[b] * 0x1000 + map[c] * 0x40 + map[d]

            buffer[offset] = extract(v, 16, 8)
            buffer[offset + 1] = extract(v, 8, 8)
            buffer[offset + 2] = extract(v, 0, 8)

            offset = offset + 3
        end

        if padding == 1 then
            local a, b, c = b64:byte(length - 3, length - 1)
            local v = map[a] * 0x40000 + map[b] * 0x1000 + map[c] * 0x40

            buffer[offset] = extract(v, 16, 8)
            buffer[offset + 1] = extract(v, 8, 8)
        elseif padding == 2 then
            local a, b = b64:byte(length - 3, length - 2)
            local v = map[a] * 0x40000 + map[b] * 0x1000

            buffer[offset] = extract(v, 16, 8)
        end

        return buffer
    end

    return Base64
end)
