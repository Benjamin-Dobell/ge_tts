---@class ge_tts__Coroutine
local Coroutine = {}

--- Yields from the current coroutine, to be resumed once a condition is met or an optional timeout limit is reached.
---@param condition fun(): boolean @Return true when the current coroutine should be resumed.
---@param timeout number|nil @Timeout in seconds (optional).
---@return boolean @Return whether the condition was met or not.
---@overload fun(condition: fun():boolean):boolean
function Coroutine.yieldCondition(condition, timeout)
    local co = coroutine.running()

    local timeOutFunc
    if type(timeout) == "number" then
        timeOutFunc = function()
            coroutine.resume(co, false)
        end
    end

    local function resume()
        coroutine.resume(co, true)
    end

    Wait.condition(resume, condition, timeout, timeOutFunc)

    return coroutine.yield()
end

--- Yields from the current coroutine, which will later be resumed after the specified number of frames have passed.
---@param frames number
function Coroutine.yieldFrames(frames)
    local co = coroutine.running()

    Wait.frames(function()
        coroutine.resume(co)
    end, frames)

    coroutine.yield()
end

--- Yields from the current coroutine, which will later be resumed after the specified number of seconds have passed.
---@param seconds number
function Coroutine.yieldSeconds(seconds)
    local co = coroutine.running()

    Wait.time(function()
        coroutine.resume(co)
    end, seconds)

    coroutine.yield()
end

--- Creates a co-routine from the specified function, and immediately starts it.
---@param func fun
---@return boolean, any...
function Coroutine.start(func)
    return coroutine.resume(coroutine.create(func))
end

return Coroutine
